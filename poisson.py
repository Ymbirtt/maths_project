from __future__ import division
from random import *
from pylab import *   
from scipy.cluster.vq import *


def poissonFun(lambMax, lamb, tmax):
    vs = [0]
    
    v = 0
    u = 0
    
    while v < tmax:
        v = v + expovariate(1/lambMax)
        u = uniform(0,lambMax)
        while u > lamb(v):
            v = v + expovariate(1/lambMax)
            u = uniform(0,lambMax)
            
        vs.append(v)
        
    return vs[:-1]
    
def poisson(lamb, tmax):
    vs = [0]   
    v = 0
    
    while v < tmax:
        v = v + expovariate(lamb)
        vs.append(v)
        
    return vs[:-1]
    
def poissonFun2(lambMax, lamb, tmax):
    vs = poisson(lambMax, tmax)
    xmax = len(vs)
    x=1
    
    while x<xmax:
        if uniform(0,1)>lamb(vs[x])/lambMax:
            vs.pop(x)
            xmax=xmax-1
        else:
            x=x+1
    return vs
        

def plotPoisson(xs, args=''):
    """Given a list of values generated by a poisson process, 
    adds them to a plot in the canonical fashion
    show() must be called afterwards to display the plot"""
	
    ys = [x for x in range(len(xs)) for _ in (0,1)][:-1]
    
    xs = [xs[0]]+[x for x in xs[1:] for _ in (0,1)]

    plot(xs,ys,args)

def foo(x):
    return 20*sin(x/5)+20
    
def baz(x):
    if x<100:
        return 1
    return 0.5
    
def main():
    ys = []
    
    samples = 1000
    bins = 100
    
    tmax = 200
    lmax = 1
    
    for _ in range(samples):    
        xs = poissonFun2(lmax,baz,tmax)
        #plotPoisson(xs)
        #show()
        ys=xs[1:]+ys
        
    #show()
    ys.sort()
    #plotPoisson(ys)
    #show()
 
    ys,_,_= hist(ys,bins)
    cla()
    
    
    ys = [(y*bins)/(samples*tmax) for y in ys]

    bar(arange (0,tmax,tmax/bins),ys,tmax/bins)
    plot([baz(x) for x in range(0,tmax)],'red')
    show()

    ys = [(ys[x-2] + ys[x-1]+ys[x]+ys[x+1]+ys[x+2])/5 for x in range(2,len(ys)-2)]
    bar(arange (0,tmax,tmax/bins)[2:-2],ys,tmax/bins)
    plot([baz(x) for x in range(0,tmax)],'red')
    show()

    means=[m*sqrt(var(ys)) for m in kmeans(whiten(ys),2)]

    print means

    diffs = [(ys[x]-ys[x-1])/(bins/tmax) for x in range(1,len(ys))]
    diffs = filter(None,diffs)

    scatter([log(abs(d)) for d in diffs],[0 for _ in diffs])
    show()

    print mean(diffs) 
    print diffs
	
    
if __name__ == "__main__":
	main()

