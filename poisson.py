from __future__ import division
from random import *
from pylab import *   

def poissonFun(lambMax, lamb, tmax):
    vs = [0]
    
    v = 0
    u = 0
    
    while v < tmax:
        v = v + expovariate(1/lambMax)
        u = uniform(0,lambMax)
        while u > lamb(v):
            v = v + expovariate(1/lambMax)
            u = uniform(0,lambMax)
            
        vs.append(v)
        
    return vs[:-1]
    
def poisson(lamb, tmax):
    vs = [0]   
    v = 0
    
    while v < tmax:
        v = v + expovariate(1/lamb)
        vs.append(v)
        
    return vs[:-1]

#TODO, this is slightly slower than it could be, vs.remove is probably linear 
#time, so cycling through indices is likely much faster    
def poissonFun2(lambMax, lamb, tmax):
    vs = poisson(lambMax, tmax)
    
    
    
    for v in vs[1:]:
        if uniform(0,1) > lamb(v)/lambMax: vs.remove(v)
        
    return vs
        

def plotPoisson(xs, args=''):
    """Given a list of values generated by a poisson process, 
    adds them to a plot in the canonical fashion
    show() must be called afterwards to display the plot"""
	
    ys = [x for x in range(len(xs)) for _ in (0,1)][:-1]
    
    xs = [xs[0]]+[x for x in xs[1:] for _ in (0,1)]

    plot(xs,ys,args)

def foo(x):
    if x<50: return 5
    return 10
    
def main():
    xs = poissonFun2(10,foo,100)
    plotPoisson(xs)
    
    show()
	
	
    
if __name__ == "__main__":
	main()

